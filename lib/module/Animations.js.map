{"version":3,"sources":["Animations.ts"],"names":["Animated","useMemoOne","min","Value","set","add","multiply","cond","eq","abs","sub","interpolate","not","diff","lessThan","greaterThan","moving","position","minPositionDelta","emptyFrameThreshold","delta","noMovementFrames","snapPoint","value","velocity","points","point","diffPoint","p","deltas","map","minDelta","reduce","acc","bInterpolate","origin","destination","inputRange","outputRange","useValues","values","deps","v","useNamedValues","result","Object","keys","forEach","key"],"mappings":"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","sourcesContent":["import Animated from \"react-native-reanimated\";\nimport { useMemoOne } from \"use-memo-one\";\n\nimport { min } from \"./Math\";\n\nconst {\n  Value,\n  set,\n  add,\n  multiply,\n  cond,\n  eq,\n  abs,\n  sub,\n  interpolate,\n  not,\n  diff,\n  lessThan,\n  greaterThan\n} = Animated;\n\nexport type SpringConfig = Partial<Omit<Animated.SpringConfig, \"toValue\">>;\nexport type TimingConfig = Partial<Omit<Animated.TimingConfig, \"toValue\">>;\n\nexport const moving = (\n  position: Animated.Node<number>,\n  minPositionDelta: number = 1e-3,\n  emptyFrameThreshold: number = 5\n) => {\n  const delta = diff(position);\n  const noMovementFrames = new Value(0);\n  return cond(\n    lessThan(abs(delta), minPositionDelta),\n    [\n      set(noMovementFrames, add(noMovementFrames, 1)),\n      not(greaterThan(noMovementFrames, emptyFrameThreshold))\n    ],\n    [set(noMovementFrames, 0), 1]\n  );\n};\n\nexport const snapPoint = (\n  value: Animated.Adaptable<number>,\n  velocity: Animated.Adaptable<number>,\n  points: Animated.Adaptable<number>[]\n) => {\n  const point = add(value, multiply(0.2, velocity));\n  const diffPoint = (p: Animated.Adaptable<number>) => abs(sub(point, p));\n  const deltas = points.map(p => diffPoint(p));\n  const minDelta = min(...deltas);\n  return points.reduce(\n    (acc, p) => cond(eq(diffPoint(p), minDelta), p, acc),\n    new Value()\n  );\n};\n\nexport const bInterpolate = (\n  value: Animated.Adaptable<number>,\n  origin: Animated.Adaptable<number>,\n  destination: Animated.Adaptable<number>\n) =>\n  interpolate(value, {\n    inputRange: [0, 1],\n    outputRange: [origin, destination]\n  });\n\ntype Dependencies = readonly unknown[];\ntype Atomic = string | number | boolean;\n\nexport const useValues = <V extends Atomic>(\n  values: V[],\n  deps: Dependencies\n): Animated.Value<V>[] => useMemoOne(() => values.map(v => new Value(v)), deps);\n\nexport const useNamedValues = <V extends Atomic, K extends string>(\n  values: Record<K, V>,\n  deps: Dependencies\n): Record<K, Animated.Value<V>> =>\n  useMemoOne(() => {\n    const result: Record<string, Animated.Value<V>> = {};\n    Object.keys(values).forEach(key => {\n      result[key as K] = new Value(values[key as K]);\n    });\n    return result;\n  }, deps);\n"]}